# Компіляція та запуск Java-програми

Перш за все нам треба познайомитись з трьома важливими абревіатурами - **JVM**,**JDK** і **JRE**.
Найростіше це, мабуть, зробити за допомогою ось такого веселого малюнка:

![abbreviations](https://raw.githubusercontent.com/ppc-ntu-khpi/oop/gh-pages/img-modules/Java-Abbreviations.png)

Тобто **JVM** - це **J**ava **V**irtual **M**achine - основний компонент середовища виконання нашого коду - **віртуальна машина,
яка виконує проміжний - байт-код** (пам’ятаєте ми говорили, що Java - це мова подвійної компіляції?), який отримується
у результаті компіляції наших файлів з вихідними кодами.

**JDK** - це **J**ava **D**evelopment **K**it - все, що вам необхідно для розробки програм мовою Java - **інструменти,
документація, зразки коду, середовище виконання (JVM), бібліотека стандартних класів (JRE)**...

**JRE** - це **J**ava **R**untime **E**nvironment - все, що вам необхідно для виконання програм, побудованих з використанням
стандартних будівельних блоків - **набір (бібліотека, Java API) класів, які ви можете використовувати в своїх додатках**. Тож велосипед
винаходити вже не потрібно - все вже написано до нас - JRE надає сотні тисяч готових класів, які вже реалізують
найрізноманітнішу стандартну функціональність.

## Віртуальна машина Java (JVM)

Віртуальна машина Java - це **додатковий рівень абстракції** над ОС та "залізом" ПК. Саме вона виконує ваш байт-код, тобто
дозволяє вашому додатку виконуватись **незалежно від того, на якій платформі побудований та під керуванням якої ОС працює
ваш ПК**. По суті, віртуальна машина - це уявне, **емульоване** на реальній машині, стандартне середовище виконання для ваших
.class-файлів, отриманих в результаті компіляції .java-файлів. В процесі роботи віртуальна машина контролює всі аспекти
виконання коду - перевіряє байт-код, завантажує його, виконує купу перевірок безпеки, сумісності, керує пам’яттю тощо.

Ще один важливий момент - це наявність **Специфікації віртуальної машини Java**, яка регламентує всі аспекти емуляції середовища
виконання байт-коду Java. Ідея полягає в тому, шоб стандартизувати різні віртуальні машини від разних виробників - **будь-яка
віртуальна машина, яка відповідає специфікації, має бути здатною виконати будь-який .class - файл**. Наступний малюнок містить
перелік аспектів, які регламентує специфікація:

![JVM](https://raw.githubusercontent.com/ppc-ntu-khpi/oop/gh-pages/img-modules/JVM.png)

Таким чином, шлях від вихідного коду до виконуваної програми виглядає досить простим - ви пишете код на Java і зберігаєте його
у файлі з розширенням .java, потім компілятор перетворює його на байт-код (.class-файл), який і виконує віртуальна машина:

![JVM-workflow](https://raw.githubusercontent.com/ppc-ntu-khpi/oop/gh-pages/img-modules/JVM-workflow.png)

В цьому ланцюжку можуть бути й додаткові ланки, такі як компресія байт-коду тощо, однак, поки що нас це не надто хвилює.

До речі, код машина **інтерпретує**, тобто читає код з файлу та виконує його
порядково - на відміну від **компілятора**, який переглядає весь проміжний код, перетворює його на машинні коди, а вже потім
запускає його на виконання - як це робить конкуруюча технологія - .NET. Тому Java-програми завантажуються швидше, однак виконуються
дещо повільніше за .NET-програми, які завантажуються значно довше, проте виконуються швидше. Раніше ми також говорили, що віртуальна машина виконує купу інших обов’язків - завантажує класи з відповідних .class-файлів,
перевіряє їх на валідність, звільняє пам’ять від непотрібних більше об’єктів (прибирає сміття) тощо. Для виконання цих завдань
у складі віртуальної машини євідповідні компоненти:

![JVM-components](https://raw.githubusercontent.com/ppc-ntu-khpi/oop/gh-pages/img-modules/JVM-components.png)

Про збір сміття ми ще будемо далі говорити детальніше. Поки що просто зазначимо, що від того наскільки ефективним є алгоритм,
за яким побудовано **збирач сміття** (Garbage Collector) дуже сильно залежить швидкодія виконання Java-програм віртуальною
машиною взагалі. Ідея збирача сміття дуже проста - програміст просто створює необхідні йому об’єкти і використовує їх - все!
Його не цікавлять "низькорівневі" аспекти вивільнення пам’яті від непотрібних більше об’єктів - це робиться автоматично й
відволікатись на це не потрібно - краще зосередитись на логіці роботи додатку! Проста і зрозуміла аналогія - автоматична коробка
передач в автомобілі - наше завдання - зосередитись на керуванні рухом машини та слідуванні правилам дорожнього руху, а
перемикати передачі - це не справа водія, йому не варто на це відволікатись - машина має робити це самостійно. В інших мовах
(наприклад, С++) збір сміття - це обов’язок самого програміста - все, що створили, після використання ви маєте й знищити.
В Java ж це робить збирач сміття, який працює у **виділенному системному потоці** і відслідковує виділення ресурсів (оперативної пам’яті).
Його основне завдання - **знайти та вивільнити пам’ять**, яка більше не потрібна. Працює він у повністю автоматичному режимі
й **передбачити коли саме він "вийде на полювання" неможливо**. Реалізація збирача сміття дуже сильно різниться у різних
віртуальних машинах від різних виробників (в Android вона також, на жаль, не є ідеальною).

## Середовище виконання Java (JRE)

